<!DOCTYPE html>
<html>
<head>
    <title>Teckel Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        :root{
            --bg: #f9f9f9;
            --text: #228B22;
            --canvas-bg: #90EE90;
            --grid-color: #228B22;
            --panel-bg: lightgray;
            --panel-border: #228B22;
            --button-bg: #228B22;
            --button-text: #ffffff;
            --control-bg: #228B22;
        }

        .dark{
            --bg: #071016;
            --text: #90EE90;
            --canvas-bg: #06331a; /* darker green */
            --grid-color: #2ecc71;
            --panel-bg: #0f1720;
            --panel-border: #2ecc71;
            --button-bg: #1f7a3a;
            --button-text: #e6ffe6;
            --control-bg: #1f7a3a;
        }

        body {
            text-align: center;
            font-family: Arial, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 10px;
            touch-action: manipulation;
            overflow: hidden;
            transition: background-color 220ms ease, color 220ms ease;
        }
        #gameContainer {
            margin: 0 auto;
            max-width: 90vw;
            max-height: 90vh;
            position: relative;
        }
        canvas {
            border: 1px solid var(--grid-color);
            display: block;
            margin: 0 auto;
            background-color: var(--canvas-bg);
            transition: background-color 220ms ease, border-color 220ms ease;
        }
        #score, #bestScore {
            font-size: 18px;
            margin: 5px auto;
            color: var(--text);
        }
        #bestScore {
            font-weight: bold;
            font-size: 16px;
        }
        /* Pause button is visible on all sizes now */
        #pauseButton {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: var(--button-bg);
            color: var(--button-text);
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 20px;
            z-index: 100;
            display: block;
            cursor: pointer;
        }
        #themeToggle {
            position: fixed;
            top: 10px;
            left: 10px;
            background-color: transparent;
            color: var(--text);
            border: 2px solid var(--panel-border);
            border-radius: 8px;
            padding: 6px 8px;
            font-size: 18px;
            z-index: 110;
            cursor: pointer;
            transition: background-color 200ms ease, color 200ms ease, border-color 200ms ease;
            background: rgba(255,255,255,0.05);
        }
        #controls {
            display: none;
            margin: 10px auto;
            width: 200px;
            height: 200px;
            position: relative;
        }
        .arrow {
            position: absolute;
            width: 50px;
            height: 50px;
            background-color: var(--control-bg);
            color: var(--button-text);
            border: none;
            border-radius: 50%;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: manipulation;
        }
        #up { top: 0; left: 75px; }
        #down { bottom: 0; left: 75px; }
        #left { top: 75px; left: 0; }
        #right { top: 75px; right: 0; }

        #pauseScreen, #gameOverScreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            z-index: 100;
        }
        #pauseScreen div, #gameOverScreen div {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--panel-bg);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border: 3px solid var(--panel-border);
            width: 80%;
            max-width: 300px;
            color: var(--text);
        }
        #restartButton, #resumeButton, #enableMotion {
            background-color: var(--button-bg);
            color: var(--button-text);
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            width: 100%;
        }
        #restartButton:hover, #resumeButton:hover, #enableMotion:hover {
            filter: brightness(0.9);
        }

        /* Media Queries */
        @media (max-width: 768px) {
            #score, #bestScore {
                font-size: 20px;
            }
            #controls {
                display: block;
            }
            canvas {
                width: 95vw;
                height: 95vw;
                max-width: 400px;
                max-height: 400px;
            }
            #themeToggle { top: 70px; } /* avoid overlapping pause button area on tiny screens */
        }
        @media (min-width: 769px) {
            canvas {
                width: 400px;
                height: 400px;
            }
        }

        .title { color: var(--text); }
    </style>
</head>
<body>
    <button id="themeToggle" aria-label="Toggle theme">üåô</button>
    <h1 class="title">Teckel Game</h1>
    <div id="score">Score: 0</div>
    <div id="bestScore">Meilleur score: 0</div>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    </div>

    <!-- Pause button (visible on desktop and mobile). Space toggles pause too. -->
    <button id="pauseButton" title="Pause">‚è∏</button>

    <div id="controls">
        <button id="up" class="arrow">‚Üë</button>
        <button id="down" class="arrow">‚Üì</button>
        <button id="left" class="arrow">‚Üê</button>
        <button id="right" class="arrow">‚Üí</button>
    </div>
    <p>Sur mobile : penchez votre t√©l√©phone pour diriger le teckel ou utilisez les boutons.</p>

    <!-- Motion permission button (required on some iOS versions) -->
    <div id="motionPermissionContainer" style="max-width:300px;margin:0 auto;padding:10px;display:none;">
        <button id="enableMotion">Activer les contr√¥les par mouvement</button>
    </div>

    <div id="pauseScreen">
        <div>
            <h2>Pause</h2>
            <button id="resumeButton">Reprendre</button>
        </div>
    </div>
    <div id="gameOverScreen">
        <div>
            <h2>Game Over !</h2>
            <p id="finalScore" style="font-size: 18px;">Score final : 0</p>
            <button id="restartButton">Rejouer</button>
        </div>
    </div>
    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const scoreElement = document.getElementById("score");
        const bestScoreElement = document.getElementById("bestScore");
        const finalScoreElement = document.getElementById("finalScore");
        const restartButton = document.getElementById("restartButton");
        const resumeButton = document.getElementById("resumeButton");
        const pauseButton = document.getElementById("pauseButton");
        const pauseScreen = document.getElementById("pauseScreen");
        const upButton = document.getElementById("up");
        const downButton = document.getElementById("down");
        const leftButton = document.getElementById("left");
        const rightButton = document.getElementById("right");
        const motionPermissionContainer = document.getElementById('motionPermissionContainer');
        const enableMotionBtn = document.getElementById('enableMotion');
        const themeToggle = document.getElementById('themeToggle');

        let box = 20; // will be recalculated
        let teckel = [];
        let food = { x: 0, y: 0 };
        let score = 0;
        let bestScore = parseInt(localStorage.getItem("teckelBestScore") || "0", 10);
        bestScoreElement.textContent = "Meilleur score: " + bestScore;
        let d = undefined; // current direction: "LEFT","RIGHT","UP","DOWN"
        let gameInterval = null;
        let isPaused = false;
        let lastDirection = null; // used to prevent reversing into self
        let allowMotion = false;

        // Theme (dark/light) persisted
        const THEME_KEY = 'teckelTheme';
        function applyTheme(theme) {
            if (theme === 'dark') {
                document.documentElement.classList.add('dark');
                themeToggle.textContent = '‚òÄÔ∏è';
                themeToggle.setAttribute('aria-label','Switch to light theme');
            } else {
                document.documentElement.classList.remove('dark');
                themeToggle.textContent = 'üåô';
                themeToggle.setAttribute('aria-label','Switch to dark theme');
            }
            localStorage.setItem(THEME_KEY, theme);
        }
        // restore theme on load
        const savedTheme = localStorage.getItem(THEME_KEY) || 'light';
        applyTheme(savedTheme);

        themeToggle.addEventListener('click', () => {
            const current = document.documentElement.classList.contains('dark') ? 'dark' : 'light';
            applyTheme(current === 'dark' ? 'light' : 'dark');
        });

        // Helper: compute box & set proper canvas pixel dimensions
        function resizeCanvas() {
            if (window.innerWidth <= 768) {
                const size = Math.min(window.innerWidth * 0.95, 400);
                canvas.width = Math.floor(size);
                canvas.height = Math.floor(size);
            } else {
                canvas.width = 400;
                canvas.height = 400;
            }
            // Use an integer grid size to avoid sub-pixel positions
            box = Math.floor(canvas.width / 20) || 20;

            // ensure score/food and teckel remain aligned to the grid after resize:
            teckel = teckel.map(segment => ({
                x: Math.round(segment.x / box) * box,
                y: Math.round(segment.y / box) * box
            }));

            food.x = Math.round(food.x / box) * box;
            food.y = Math.round(food.y / box) * box;
        }

        window.addEventListener('resize', () => {
            const wasRunning = !!gameInterval && !isPaused;
            clearInterval(gameInterval);
            resizeCanvas();
            if (wasRunning) {
                gameInterval = setInterval(drawGame, 100);
            }
        });

        // initial sizing
        resizeCanvas();

        // Reset / start game state
        function resetGame() {
            teckel = [{ x: 9 * box, y: 10 * box }];
            food = {
                x: Math.floor(Math.random() * (canvas.width / box)) * box,
                y: Math.floor(Math.random() * (canvas.height / box)) * box
            };
            score = 0;
            scoreElement.textContent = "Score: " + score;
            d = undefined;
            lastDirection = "RIGHT";
            isPaused = false;
            pauseScreen.style.display = "none";
            document.getElementById("gameOverScreen").style.display = "none";
            // ensure pause button shows pause icon when game reset
            pauseButton.textContent = '‚è∏';
            pauseButton.disabled = false;
        }

        // Motion controls (gyroscope)
        function handleOrientation(event) {
            if (!allowMotion) return;
            const gamma = event.gamma; // left/right
            const beta = event.beta;   // front/back

            if (Math.abs(gamma) > Math.abs(beta)) {
                if (gamma < -12 && lastDirection !== "RIGHT") {
                    d = "LEFT"; lastDirection = "LEFT";
                } else if (gamma > 12 && lastDirection !== "LEFT") {
                    d = "RIGHT"; lastDirection = "RIGHT";
                }
            } else {
                if (beta > 12 && lastDirection !== "DOWN") {
                    d = "UP"; lastDirection = "UP";
                } else if (beta < -12 && lastDirection !== "UP") {
                    d = "DOWN"; lastDirection = "DOWN";
                }
            }
        }

        function drawGrid() {
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid-color').trim();
            ctx.lineWidth = Math.max(1, canvas.width / 400 * 1.5);
            for (let i = 0; i <= canvas.width; i += box) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i <= canvas.height; i += box) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }
        }

        function drawGame() {
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--canvas-bg').trim();
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawGrid();

            for (let i = 0; i < teckel.length - 1; i++) {
                ctx.fillStyle = "#8B4513";
                ctx.fillRect(teckel[i].x, teckel[i].y, box, box);
            }

            const head = teckel[teckel.length - 1];
            ctx.fillStyle = "#A0522D";
            ctx.fillRect(head.x, head.y, box, box);

            ctx.fillStyle = "#D2B48C";
            ctx.beginPath();
            ctx.ellipse(head.x + box * 0.25, head.y - box * 0.15, box * 0.25, box * 0.18, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(head.x + box * 0.75, head.y - box * 0.15, box * 0.25, box * 0.18, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(head.x + box * 0.25, head.y + box * 0.25, box * 0.12, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(head.x + box * 0.75, head.y + box * 0.25, box * 0.12, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = "black";
            const pupilOffset = box * 0.06;
            if (d === "LEFT") {
                ctx.fillRect(head.x + box * 0.17 - pupilOffset, head.y + box * 0.25, box * 0.12, box * 0.12);
                ctx.fillRect(head.x + box * 0.67 - pupilOffset, head.y + box * 0.25, box * 0.12, box * 0.12);
            } else if (d === "RIGHT") {
                ctx.fillRect(head.x + box * 0.17 + pupilOffset, head.y + box * 0.25, box * 0.12, box * 0.12);
                ctx.fillRect(head.x + box * 0.67 + pupilOffset, head.y + box * 0.25, box * 0.12, box * 0.12);
            } else if (d === "UP") {
                ctx.fillRect(head.x + box * 0.25, head.y + box * 0.17 - pupilOffset, box * 0.12, box * 0.12);
                ctx.fillRect(head.x + box * 0.75 - box * 0.5, head.y + box * 0.17 - pupilOffset, box * 0.12, box * 0.12);
            } else {
                ctx.fillRect(head.x + box * 0.25, head.y + box * 0.33 + pupilOffset, box * 0.12, box * 0.12);
                ctx.fillRect(head.x + box * 0.75 - box * 0.5, head.y + box * 0.33 + pupilOffset, box * 0.12, box * 0.12);
            }

            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.ellipse(head.x + box / 2, head.y + box * 0.75, box * 0.25, box * 0.12, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = "white";
            ctx.fillRect(food.x, food.y, box, box);
            ctx.fillStyle = "pink";
            ctx.fillRect(food.x + box/4, food.y + box/4, box/3, box/3);
            ctx.fillRect(food.x + 2*box/3 - box/6, food.y + box/4, box/3, box/3);
            ctx.fillStyle = "black";
            ctx.fillRect(food.x + box/3, food.y + box/2, box/6, box/6);
            ctx.fillRect(food.x + box/2, food.y + box/2, box/6, box/6);
            ctx.fillStyle = "red";
            ctx.fillRect(food.x + box/4, food.y + 3*box/4, 2*box/3, box/5);

            let nextX = head.x;
            let nextY = head.y;
            if (d === "LEFT") nextX -= box;
            if (d === "RIGHT") nextX += box;
            if (d === "UP") nextY -= box;
            if (d === "DOWN") nextY += box;

            if (nextX < 0) nextX = canvas.width - box;
            if (nextX >= canvas.width) nextX = 0;
            if (nextY < 0) nextY = canvas.height - box;
            if (nextY >= canvas.height) nextY = 0;

            if (nextX === food.x && nextY === food.y) {
                score++;
                scoreElement.textContent = "Score: " + score;
                setTimeout(() => {
                    food = {
                        x: Math.floor(Math.random() * (canvas.width / box)) * box,
                        y: Math.floor(Math.random() * (canvas.height / box)) * box
                    };
                }, 80);
            } else {
                teckel.shift();
            }

            const newHead = { x: nextX, y: nextY };

            if (collision(newHead, teckel)) {
                clearInterval(gameInterval);
                updateBestScore();
                showGameOver();
                return;
            }

            teckel.push(newHead);
        }

        function collision(head, array) {
            for (let i = 0; i < array.length; i++) {
                if (head.x === array[i].x && head.y === array[i].y) return true;
            }
            return false;
        }

        function updateBestScore() {
            if (score > bestScore) {
                bestScore = score;
                bestScoreElement.textContent = "Meilleur score: " + bestScore;
                localStorage.setItem("teckelBestScore", String(bestScore));
            }
        }

        // Keyboard controls - arrows for movement, Space to toggle pause
        function changeDirection(e) {
            const key = e.keyCode;
            if (key === 37 && d !== "RIGHT") { d = "LEFT"; lastDirection = "LEFT"; }
            if (key === 38 && d !== "DOWN") { d = "UP"; lastDirection = "UP"; }
            if (key === 39 && d !== "LEFT") { d = "RIGHT"; lastDirection = "RIGHT"; }
            if (key === 40 && d !== "UP") { d = "DOWN"; lastDirection = "DOWN"; }
        }

        function handleKeydown(e) {
            // Space toggles pause/resume
            if (e.code === 'Space' || e.keyCode === 32) {
                e.preventDefault();
                togglePause();
                return;
            }
            // Otherwise handle arrow keys
            changeDirection(e);
        }

        function togglePause() {
            isPaused = !isPaused;
            if (isPaused) {
                clearInterval(gameInterval);
                pauseScreen.style.display = "block";
                window.removeEventListener("deviceorientation", handleOrientation);
                pauseButton.textContent = '‚ñ∂Ô∏è';
            } else {
                gameInterval = setInterval(drawGame, 100);
                pauseScreen.style.display = "none";
                if (allowMotion) window.addEventListener("deviceorientation", handleOrientation);
                pauseButton.textContent = '‚è∏';
            }
        }

        function showGameOver() {
            finalScoreElement.textContent = "Score final : " + score;
            document.getElementById("gameOverScreen").style.display = "block";
            window.removeEventListener("deviceorientation", handleOrientation);
            // reset pause button to default state and disable it while showing game over
            pauseButton.textContent = '‚è∏';
            pauseButton.disabled = true;
        }

        // Touch buttons (touchstart)
        upButton.addEventListener("touchstart", (e) => { e.preventDefault(); if (d !== "DOWN") { d = "UP"; lastDirection = "UP"; } });
        downButton.addEventListener("touchstart", (e) => { e.preventDefault(); if (d !== "UP") { d = "DOWN"; lastDirection = "DOWN"; } });
        leftButton.addEventListener("touchstart", (e) => { e.preventDefault(); if (d !== "RIGHT") { d = "LEFT"; lastDirection = "LEFT"; } });
        rightButton.addEventListener("touchstart", (e) => { e.preventDefault(); if (d !== "LEFT") { d = "RIGHT"; lastDirection = "RIGHT"; } });

        // Pause button click toggles pause (and updates icon)
        pauseButton.addEventListener("click", () => {
            togglePause();
        });

        restartButton.addEventListener("click", function() {
            resetGame();
            clearInterval(gameInterval);
            gameInterval = setInterval(drawGame, 100);
            if (allowMotion) window.addEventListener("deviceorientation", handleOrientation);
        });

        resumeButton.addEventListener("click", function() {
            togglePause();
        });

        // Visibility change -> pause the game when tab is hidden
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && gameInterval) {
                isPaused = true;
                clearInterval(gameInterval);
                pauseButton.textContent = '‚ñ∂Ô∏è';
            } else if (!document.hidden && isPaused) {
                isPaused = false;
                gameInterval = setInterval(drawGame, 100);
                pauseButton.textContent = '‚è∏';
            }
        });

        // Motion permission handling for iOS 13+ (must be invoked from user gesture)
        function showMotionPermissionIfNeeded() {
            if (typeof DeviceOrientationEvent !== 'undefined' &&
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                motionPermissionContainer.style.display = 'block';
            }
        }

        enableMotionBtn.addEventListener('click', async () => {
            if (typeof DeviceOrientationEvent !== 'undefined' &&
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const res = await DeviceOrientationEvent.requestPermission();
                    if (res === 'granted') {
                        allowMotion = true;
                        window.addEventListener("deviceorientation", handleOrientation);
                        motionPermissionContainer.style.display = 'none';
                    } else {
                        allowMotion = false;
                        alert('Permission aux mouvements refus√©e.');
                    }
                } catch (err) {
                    console.error('Permission request failed', err);
                }
            } else {
                allowMotion = true;
                window.addEventListener("deviceorientation", handleOrientation);
                motionPermissionContainer.style.display = 'none';
            }
        });

        // Start the game
        document.addEventListener("keydown", handleKeydown);

        if (window.innerWidth <= 768) {
            showMotionPermissionIfNeeded();
            if (!(typeof DeviceOrientationEvent !== 'undefined' &&
                typeof DeviceOrientationEvent.requestPermission === 'function')) {
                allowMotion = true;
                window.addEventListener("deviceorientation", handleOrientation);
            }
        }

        // initialize and start
        resetGame();
        clearInterval(gameInterval);
        gameInterval = setInterval(drawGame, 100);
    </script>
</body>
</html>
